// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.27;

// Imports
import "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol";
import "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
import "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
import {TimelockController} from "@openzeppelin/contracts/governance/TimelockController.sol";
import "@openzeppelin/contracts/proxy/beacon/IBeacon.sol";
import "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol";
import "forge-std/Test.sol";

import "src/contracts/core/DelegationManager.sol";
import "src/contracts/core/AllocationManager.sol";
import "src/contracts/core/AllocationManagerView.sol";
import "src/contracts/core/StrategyManager.sol";
import "src/contracts/strategies/StrategyFactory.sol";
import "src/contracts/strategies/StrategyBase.sol";
import "src/contracts/strategies/StrategyBaseTVLLimits.sol";
import "src/contracts/pods/EigenPodManager.sol";
import "src/contracts/pods/EigenPod.sol";
import "src/contracts/permissions/PauserRegistry.sol";
import "src/contracts/permissions/PermissionController.sol";

import "src/test/mocks/EmptyContract.sol";
import "src/test/mocks/ETHDepositMock.sol";
import "src/test/integration/mocks/BeaconChainMock.t.sol";

import "src/test/integration/users/AVS.t.sol";
import "src/test/integration/users/User.t.sol";

import "script/utils/ExistingDeploymentParser.sol";

IStrategy constant beaconChainETHStrategy = IStrategy(0xbeaC0eeEeeeeEEeEeEEEEeeEEeEeeeEeeEEBEaC0);

abstract contract IntegrationDeployer is ExistingDeploymentParser {
    using StdStyle for *;
    using ArrayLib for *;

    // Fork ids for specific fork tests
    bool isUpgraded;
    uint mainnetForkBlock = 24_250_112; // Post Slashing UX Improvements 2.2

    string version = "9.9.9";

    // Beacon chain genesis time when running locally
    // Multiple of 12 for sanity's sake
    uint64 constant GENESIS_TIME_LOCAL = 1 hours * 12;
    uint64 constant GENESIS_TIME_MAINNET = 1_606_824_023;
    uint64 BEACON_GENESIS_TIME; // set after forkType is decided

    // Beacon chain deposit contract. The BeaconChainMock contract etchs ETHPOSDepositMock code here.
    IETHPOSDeposit constant DEPOSIT_CONTRACT = IETHPOSDeposit(0x00000000219ab540356cBB839Cbe05303d7705Fa);

    uint8 constant NUM_LST_STRATS = 32;

    uint32 INITIAL_GLOBAL_DELAY_BLOCKS = 4 days / 12 seconds; // 4 days in blocks

    // Lists of strategies used in the system
    //
    // When we select random user assets, we use the `assetType` to determine
    // which of these lists to select user assets from.
    IStrategy[] lstStrats;
    IStrategy[] ethStrats; // only has one strat tbh
    IStrategy[] allStrats; // just a combination of the above 2 lists
    IERC20[] allTokens; // `allStrats`, but contains all of the underlying tokens instead
    uint maxUniqueAssetsHeld;

    // If a token is in this mapping, then we will ignore this LST as it causes issues with reading balanceOf
    mapping(address => bool) public tokensNotTested;

    // Mock Contracts to deploy
    TimeMachine public timeMachine;
    BeaconChainMock public beaconChain;

    // Admin Addresses
    address constant pauser = address(555);
    address constant unpauser = address(556);

    // Randomness state vars
    bytes32 random;
    // After calling `_configRand`, these are the allowed "variants" on users that will
    // be returned from `_randUser`.
    bytes assetTypes;
    bytes userTypes;
    // Set only once in setUp, if FORK_MAINNET env is set
    uint forkType;

    /// @dev used to configure randomness and default user/asset types
    ///
    /// Tests that want alternate user/asset types can still use this modifier,
    /// and then configure user/asset types individually using the methods:
    /// _configAssetTypes(...)
    /// _configUserTypes(...)
    ///
    /// (Alternatively, this modifier can be overwritten)
    modifier rand(uint24 r) virtual {
        _configRand({_randomSeed: r, _assetTypes: HOLDS_LST | HOLDS_ETH | HOLDS_ALL, _userTypes: DEFAULT | ALT_METHODS});

        // Used to create shared setups between tests
        _init();

        _;
    }

    constructor() {
        address stETH_Mainnet = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
        address OETH_Mainnet = 0x856c4Efb76C1D1AE02e20CEB03A2A6a08b0b8dC3;
        address osETH_Mainnet = 0xf1C9acDc66974dFB6dEcB12aA385b9cD01190E38;
        tokensNotTested[stETH_Mainnet] = true;
        tokensNotTested[OETH_Mainnet] = true;
        tokensNotTested[osETH_Mainnet] = true;

        // Use current contracts by default. Upgrade tests are only run with mainnet fork tests
        // using the `UpgradeTest.t.sol` mixin.
        isUpgraded = true;
    }

    function NAME() public view virtual override returns (string memory) {
        return "Integration Deployer";
    }

    /// @dev Anyone who wants to test using this contract in a separate repo via submodules may have to
    /// override this function to set the correct paths for the deployment info files.
    ///
    /// This setUp function will account for specific --fork-url flags and deploy/upgrade contracts accordingly.
    /// Note that forkIds are also created so you can make explicit fork tests using cheats.selectFork(forkId)
    function setUp() public virtual {
        bool forkMainnet = isForktest();

        if (forkMainnet) {
            console.log("Forking mainnet");
            forkType = MAINNET;
            _setUpMainnet();
        } else {
            forkType = LOCAL;
            _setUpLocal();
        }
    }

    /// @dev Used to create shared setup between tests. This method is called
    /// when the `rand` modifier is run, before a test starts
    function _init() internal virtual {
        return;
    }

    /// env FOUNDRY_PROFILE=forktest forge t --mc Integration
    ///
    /// Running foundry like this will trigger the fork test profile,
    /// lowering fuzz runs and using a remote RPC to test against mainnet state
    function isForktest() public view returns (bool) {
        return _hash("forktest") == _hash(cheats.envOr(string("FOUNDRY_PROFILE"), string("default")));
    }

    /// Deploy EigenLayer locally
    function _setUpLocal() public virtual noTracing {
        console.log("Setting up `%s` integration tests:", "LOCAL".yellow().bold());

        // Deploy ProxyAdmin
        eigenLayerProxyAdmin = new ProxyAdmin();
        executorMultisig = address(eigenLayerProxyAdmin.owner());

        // Deploy PauserRegistry
        address[] memory pausers = new address[](1);
        pausers[0] = pauser;
        eigenLayerPauserReg = new PauserRegistry(pausers, unpauser);

        // Deploy mocks
        emptyContract = new EmptyContract();

        // Matching parameters to testnet
        DELEGATION_MANAGER_MIN_WITHDRAWAL_DELAY_BLOCKS = 50;
        DEALLOCATION_DELAY = 50;
        ALLOCATION_CONFIGURATION_DELAY = 75;

        REWARDS_COORDINATOR_CALCULATION_INTERVAL_SECONDS = 86_400;
        REWARDS_COORDINATOR_MAX_REWARDS_DURATION = 6_048_000;
        REWARDS_COORDINATOR_MAX_RETROACTIVE_LENGTH = 7_776_000;
        REWARDS_COORDINATOR_MAX_FUTURE_LENGTH = 2_592_000;
        REWARDS_COORDINATOR_GENESIS_REWARDS_TIMESTAMP = 1_710_979_200;

        _deployProxies();
        _deployImplementations();
        _upgradeProxies();
        _initializeProxies();

        // Place native ETH first in `allStrats`
        // This ensures when we select a nonzero number of strategies from this array, we always
        // have beacon chain ETH
        ethStrats.push(BEACONCHAIN_ETH_STRAT);
        allStrats.push(BEACONCHAIN_ETH_STRAT);
        allTokens.push(NATIVE_ETH);

        // Deploy and configure strategies and tokens
        for (uint i = 1; i < NUM_LST_STRATS + 1; ++i) {
            string memory name = string.concat("LST-Strat", cheats.toString(i), " token");
            string memory symbol = string.concat("lstStrat", cheats.toString(i));
            // Deploy half of the strategies using the factory.
            _newStrategyAndToken(name, symbol, 10e50, address(this), i % 2 == 0);
        }

        maxUniqueAssetsHeld = allStrats.length;

        // Create time machine and beacon chain. Set block time to beacon chain genesis time and starting block number
        BEACON_GENESIS_TIME = GENESIS_TIME_LOCAL;
        cheats.warp(BEACON_GENESIS_TIME);
        cheats.roll(10_000);
        timeMachine = new TimeMachine();
        beaconChain = new BeaconChainMock(eigenPodManager, BEACON_GENESIS_TIME);

        // Set the `pectraForkTimestamp` on the EigenPodManager. Use pectra state
        cheats.startPrank(executorMultisig);
        eigenPodManager.setProofTimestampSetter(executorMultisig);
        eigenPodManager.setPectraForkTimestamp(BEACON_GENESIS_TIME);
        cheats.stopPrank();
    }

    /// Parse existing contracts from mainnet
    function _setUpMainnet() public virtual noTracing {
        console.log("Setting up `%s` integration tests:", "MAINNET_FORK".green().bold());
        console.log("RPC:", cheats.rpcUrl("mainnet"));
        console.log("Block:", mainnetForkBlock);

        cheats.createSelectFork(cheats.rpcUrl("mainnet"), mainnetForkBlock);

        string memory deploymentInfoPath = "script/configs/mainnet/mainnet-addresses.config.json";
        _parseDeployedContracts(deploymentInfoPath);
        string memory existingDeploymentParams = "script/configs/mainnet.json";
        _parseParamsForIntegrationUpgrade(existingDeploymentParams);

        // Place native ETH first in `allStrats`
        // This ensures when we select a nonzero number of strategies from this array, we always
        // have beacon chain ETH
        ethStrats.push(BEACONCHAIN_ETH_STRAT);
        allStrats.push(BEACONCHAIN_ETH_STRAT);
        allTokens.push(NATIVE_ETH);

        // Add deployed strategies to lstStrats and allStrats
        for (uint i; i < deployedStrategyArray.length; i++) {
            IStrategy strategy = IStrategy(deployedStrategyArray[i]);

            if (tokensNotTested[address(strategy.underlyingToken())]) continue;

            // Add to lstStrats and allStrats
            lstStrats.push(strategy);
            allStrats.push(strategy);
            allTokens.push(strategy.underlyingToken());
        }

        maxUniqueAssetsHeld = allStrats.length;

        // Create time machine and mock beacon chain
        BEACON_GENESIS_TIME = GENESIS_TIME_MAINNET;
        timeMachine = new TimeMachine();
        beaconChain = new BeaconChainMock(eigenPodManager, BEACON_GENESIS_TIME);

        // Since we haven't done the slashing upgrade on mainnet yet, upgrade mainnet contracts
        // prior to test. `isUpgraded` is true by default, but is set to false in `UpgradeTest.t.sol`
        if (isUpgraded) {
            _upgradeMainnetContracts();
        }
    }

    function _upgradeMainnetContracts() public virtual {
        // Warp time to past the queued upgrade transaction.
        cheats.warp(block.timestamp + 10 days);

        bytes memory payload = hex"6A76120200000000000000000000000040A2ACCBD92BCA938B02010E17A5B8929B49130D0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030800000000000000000000000000000000000000000000000000000000000002F048D80FF0A00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000002EB9008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000025E5F8B1E7ADF44518D35D5B2271F114E081F0E500000000000000000000000036DD260ABF606172875E6B5B7A96B435DC74EED2008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000054F4BC6BDEBE479173A2BBDC31DD7178408A57A40000000000000000000000000F939726AB8514C13546804311149A8CC244C219008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000948A420B8CC1D6BFD0B6087C2E7C344A2CD0BC39000000000000000000000000DA2A68D318A571DD550F2ECBCB09BF50497E97C4008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000135DDA560E946695D6F155DACAFC6F1F25C1F5AF000000000000000000000000CD35CEF328B496FA9D70A8D7C34EF3434614862B008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000039053D51B77DC0D36036FC1FCC8CB819DF8EF37A000000000000000000000000E7022A128ACD4C6CAD7AFF6FA874D61F984BCE75008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000EDA3CAD031C0CF367CF3F517EE0DC98F9BA80C8F000000000000000000000000D0CB07DF397B122BB7EBAA453356F21F8FF813BD008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000007750D328B314EFFA365A0402CCFD489B80B0ADDA000000000000000000000000788E38BCE16CD96E5588559703469EFBA3AFB0CF008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000858646372CC42E1A627FCE94AA7A7033E7CF075A000000000000000000000000E09D4A1717C936EF021E14E72328128268B0CC3C008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000091E677B07F7AF907EC9A428AAFA9FC14A0D3A338000000000000000000000000D22DD829779ADBF3869FB224F703452F7F95E9DB005A2A4F2F3C18F09179B6703E63D9EDD165909073000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000243659CFE600000000000000000000000053CC2D82E08370FE1E44A96F69CEC7D5B54AE868008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000ACB55C530ACDB2849E6D4F36992CD8C9D50ED8F70000000000000000000000004A0AEE93BE6C87B227CA0B450E15245631233532000ED6703C298D28AE0878D1B28E88CA87F9662FE9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000243659CFE6000000000000000000000000D33AACCC7E1A29BC8E09AF55F8FA6FF3301E2780008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000093C4B944D05DFE6DF7645A86CD2206016C51564D000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000001BEE69B7DFFFA4E2D53C2A2DF135C388AD25DCD2000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000054945180DB7943C0ED0FEE7EDAB2BD24620256BC000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000009D7ED45EE2E8FC5482FA2428F15C971E6369011D000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000013760F50A9D7377E4F20CB8CF9E4C26586C658FF000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000A4C637E0F704745D182E4D38CAB7E7485321D059000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000057BA429517C3473B6D34CA9ACD56C0E735B94C02000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000000FE4F44BEE93503346A3AC9EE5A26B130A5796D6000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000007CA911E83DABF90C90DD3DE5411A10F1A6112184000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000008CA7A5D6F3ACD3A7A8BC468A8CD0FB14B6BD28B6000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000AE60D8180437B5C34BB956822AC2710972584473000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000298AFB19A105D59E74658C4C334FF360BADE6DD2000000000000000000000000B8D2CC94A9D2A8FD7FF499FBE64B0B209212DBA7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000005E4C39AD7A3E881585E383DB9827EB4811F6F6470000000000000000000000005194D2A6A0900796903503926E9CF775B926C8AF008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000003F55654B2B2B86BB11BE2F72657F9C33BF88120A0000000000000000000000009907690007B7ECFE1E03F96BECA1A957FAE3EAD2008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000009376A5863F2193CDE13E1AB7C678F22554E2EA2B000000000000000000000000DC2354FADD4BF0F9857038381917D0089880642C008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000D0930EE96D07DE4F9D493C259232222E46B6EC250000000000000000000000002D52C39461795835B1F8F6CD242F4955AAC040DC008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000005557E1FE3068A1E823CE5DCD052C6C352E2617B50000000000000000000000008C4F429E6D884899EBF4602BD2691920B056ADF7008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000132B466D9D5723531F68797519DFED701AC2C749000000000000000000000000A2A9D0F957D81A0F8134F68803240F1CAD81C55E0027A84740FDDED5B7D66D9BB6E5D1DEA6EB0C0129000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011A4FC434A8A00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000000000090000000000000000000000000000000000000000000000000000000000000011600000000000000000000000000000000000000000000000000000000000000016000000000000000000000000B8765ED72235D279C3FB53936E4606DB0EF1280600000000000000000000000025E5F8B1E7ADF44518D35D5B2271F114E081F0E500000000000000000000000054F4BC6BDEBE479173A2BBDC31DD7178408A57A4000000000000000000000000948A420B8CC1D6BFD0B6087C2E7C344A2CD0BC39000000000000000000000000135DDA560E946695D6F155DACAFC6F1F25C1F5AF00000000000000000000000039053D51B77DC0D36036FC1FCC8CB819DF8EF37A00000000000000000000000027A84740FDDED5B7D66D9BB6E5D1DEA6EB0C0129000000000000000000000000EDA3CAD031C0CF367CF3F517EE0DC98F9BA80C8F0000000000000000000000007750D328B314EFFA365A0402CCFD489B80B0ADDA000000000000000000000000858646372CC42E1A627FCE94AA7A7033E7CF075A00000000000000000000000091E677B07F7AF907EC9A428AAFA9FC14A0D3A3380000000000000000000000005A2A4F2F3C18F09179B6703E63D9EDD165909073000000000000000000000000ACB55C530ACDB2849E6D4F36992CD8C9D50ED8F70000000000000000000000000ED6703C298D28AE0878D1B28E88CA87F9662FE90000000000000000000000005E4C39AD7A3E881585E383DB9827EB4811F6F6470000000000000000000000003F55654B2B2B86BB11BE2F72657F9C33BF88120A0000000000000000000000009376A5863F2193CDE13E1AB7C678F22554E2EA2B000000000000000000000000D0930EE96D07DE4F9D493C259232222E46B6EC250000000000000000000000005557E1FE3068A1E823CE5DCD052C6C352E2617B5000000000000000000000000132B466D9D5723531F68797519DFED701AC2C74900000000000000000000000083E9115D334D248CE39A6F36144AEAB5B3456E75000000000000000000000000EC53BF9167F50CDEB3AE105F56099AAAB9061F83000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000002C000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000340000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000003C000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000048000000000000000000000000000000000000000000000000000000000000004C000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000540000000000000000000000000000000000000000000000000000000000000058000000000000000000000000000000000000000000000000000000000000005C000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000068000000000000000000000000000000000000000000000000000000000000006C000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000000740000000000000000000000000000000000000000000000000000000000000078000000000000000000000000000000000000000000000000000000000000007C00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000E506175736572526567697374727900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000145065726D697373696F6E436F6E74726F6C6C6572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4B657952656769737472617200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011416C6C6F636174696F6E4D616E61676572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4156534469726563746F72790000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001144656C65676174696F6E4D616E61676572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001050726F746F636F6C526567697374727900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000E52656C656173654D616E61676572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001252657761726473436F6F7264696E61746F720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F53747261746567794D616E616765720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F456967656E506F644D616E6167657200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008456967656E506F64000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D456967656E537472617465677900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C5374726174656779426173650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F5374726174656779466163746F727900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018424E323534436572746966696361746556657269666965720000000000000000000000000000000000000000000000000000000000000000000000000000001243726F7373436861696E526567697374727900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018454344534143657274696669636174655665726966696572000000000000000000000000000000000000000000000000000000000000000000000000000000144F70657261746F725461626C6555706461746572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000B5461736B4D61696C626F78000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C4261636B696E67456967656E00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005456967656E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005312E392E300000000000000000000000000000000000000000000000000000000027A84740FDDED5B7D66D9BB6E5D1DEA6EB0C012900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000A24FC434A8A00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000054000000000000000000000000000000000000000000000000000000000000009E0000000000000000000000000000000000000000000000000000000000000000C00000000000000000000000093C4B944D05DFE6DF7645A86CD2206016C51564D0000000000000000000000001BEE69B7DFFFA4E2D53C2A2DF135C388AD25DCD200000000000000000000000054945180DB7943C0ED0FEE7EDAB2BD24620256BC0000000000000000000000009D7ED45EE2E8FC5482FA2428F15C971E6369011D00000000000000000000000013760F50A9D7377E4F20CB8CF9E4C26586C658FF000000000000000000000000A4C637E0F704745D182E4D38CAB7E7485321D05900000000000000000000000057BA429517C3473B6D34CA9ACD56C0E735B94C020000000000000000000000000FE4F44BEE93503346A3AC9EE5A26B130A5796D60000000000000000000000007CA911E83DABF90C90DD3DE5411A10F1A61121840000000000000000000000008CA7A5D6F3ACD3A7A8BC468A8CD0FB14B6BD28B6000000000000000000000000AE60D8180437B5C34BB956822AC2710972584473000000000000000000000000298AFB19A105D59E74658C4C334FF360BADE6DD2000000000000000000000000000000000000000000000000000000000000000C000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001C000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000002C000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000340000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000003C000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000001753747261746567794261736554564C4C696D6974735F30000000000000000000000000000000000000000000000000000000000000000000000000000000001753747261746567794261736554564C4C696D6974735F31000000000000000000000000000000000000000000000000000000000000000000000000000000001753747261746567794261736554564C4C696D6974735F32000000000000000000000000000000000000000000000000000000000000000000000000000000001753747261746567794261736554564C4C696D6974735F33000000000000000000000000000000000000000000000000000000000000000000000000000000001753747261746567794261736554564C4C696D6974735F34000000000000000000000000000000000000000000000000000000000000000000000000000000001753747261746567794261736554564C4C696D6974735F35000000000000000000000000000000000000000000000000000000000000000000000000000000001753747261746567794261736554564C4C696D6974735F36000000000000000000000000000000000000000000000000000000000000000000000000000000001753747261746567794261736554564C4C696D6974735F37000000000000000000000000000000000000000000000000000000000000000000000000000000001753747261746567794261736554564C4C696D6974735F38000000000000000000000000000000000000000000000000000000000000000000000000000000001753747261746567794261736554564C4C696D6974735F39000000000000000000000000000000000000000000000000000000000000000000000000000000001853747261746567794261736554564C4C696D6974735F31300000000000000000000000000000000000000000000000000000000000000000000000000000001853747261746567794261736554564C4C696D6974735F313100000000000000000000000000000000000000000000000000000000000000000000000000000005312E392E3000000000000000000000000000000000000000000000000000000000B8765ED72235D279C3FB53936E4606DB0EF12806000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000448568520600000000000000000000000027A84740FDDED5B7D66D9BB6E5D1DEA6EB0C0129000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041000000000000000000000000C06FD4F821EAC1FF1AE8067B36342899B57BAA2D00000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000";

        TimelockController timelockController = TimelockController(payable(timelock));
        console.log("Preparing to execute upgrade");
        cheats.startPrank(0x461854d84Ee845F905e0eCf6C288DDEEb4A9533F);
        timelockController.execute({target: executorMultisig, value: 0, payload: payload, predecessor: 0, salt: 0});
        cheats.stopPrank();
        console.log("Upgrade executed");

        /// Manually set new addresses
        // core
        allocationManagerView = AllocationManagerView(0x0D4e5723daAD06510CFd6864b8eB8a08CF0c4a34);
        allocationManagerImplementation = AllocationManager(0xdA2A68D318A571dD550F2EcbCb09bf50497e97C4);
        avsDirectoryImplementation = AVSDirectory(0xcD35Cef328b496fA9d70a8d7C34EF3434614862b);
        delegationManagerImplementation = DelegationManager(0xE7022a128Acd4C6cad7aFf6FA874D61f984BcE75);
        rewardsCoordinatorImplementation = RewardsCoordinator(0x788E38bCe16Cd96E5588559703469efBA3Afb0cF);
        strategyManagerImplementation = StrategyManager(0xE09d4a1717C936ef021e14E72328128268B0CC3c);
        permissionControllerImplementation = PermissionController(0x36dd260AbF606172875E6B5B7A96B435DC74EEd2);

        // permissions
        eigenLayerPauserReg = PauserRegistry(0x0c431C66F4dE941d089625E5B423D00707977060);
        permissionControllerImplementation = PermissionController(0xe7f3705c9Addf2DE14e03C345fA982CAb2c1C6B1);

        // pods
        eigenPodImplementation = EigenPod(payable(0x53cC2D82E08370Fe1e44a96f69CEc7d5b54ae868));
        eigenPodManagerImplementation = EigenPodManager(0xd22dd829779ADBf3869fb224F703452f7F95E9dB);

        // strategies
        strategyFactoryImplementation = StrategyFactory(0x5194D2a6A0900796903503926E9CF775b926c8AF);
        eigenStrategyImpl = EigenStrategy(0x4a0aee93BE6C87B227cA0B450E15245631233532);
        strategyFactoryBeaconImplementation = StrategyBase(0xd33AAccc7E1a29Bc8E09Af55F8fa6fF3301e2780);
        baseStrategyImplementation = StrategyBase(0xb8d2cc94A9d2a8Fd7fF499fbE64B0B209212DBa7);

        // multichain
        keyRegistrarImplementation = KeyRegistrar(0x0f939726Ab8514c13546804311149a8CC244C219);


        console.log("Upgrade executed after queue");
    }

    function _deployProxies() public {
        if (address(delegationManager) == address(0)) {
            delegationManager =
                DelegationManager(address(new TransparentUpgradeableProxy(address(emptyContract), address(eigenLayerProxyAdmin), "")));
        }
        if (address(strategyManager) == address(0)) {
            strategyManager =
                StrategyManager(address(new TransparentUpgradeableProxy(address(emptyContract), address(eigenLayerProxyAdmin), "")));
        }
        if (address(eigenPodManager) == address(0)) {
            eigenPodManager =
                EigenPodManager(address(new TransparentUpgradeableProxy(address(emptyContract), address(eigenLayerProxyAdmin), "")));
        }
        if (address(rewardsCoordinator) == address(0)) {
            rewardsCoordinator =
                RewardsCoordinator(address(new TransparentUpgradeableProxy(address(emptyContract), address(eigenLayerProxyAdmin), "")));
        }
        if (address(avsDirectory) == address(0)) {
            avsDirectory = AVSDirectory(address(new TransparentUpgradeableProxy(address(emptyContract), address(eigenLayerProxyAdmin), "")));
        }
        if (address(strategyFactory) == address(0)) {
            strategyFactory =
                StrategyFactory(address(new TransparentUpgradeableProxy(address(emptyContract), address(eigenLayerProxyAdmin), "")));
        }
        if (address(allocationManager) == address(0)) {
            allocationManager =
                IAllocationManager(address(new TransparentUpgradeableProxy(address(emptyContract), address(eigenLayerProxyAdmin), "")));
        }
        // allocationManagerView is deployed as a standalone implementation (not a proxy) in _deployImplementations()
        if (address(permissionController) == address(0)) {
            permissionController =
                PermissionController(address(new TransparentUpgradeableProxy(address(emptyContract), address(eigenLayerProxyAdmin), "")));
        }
        if (address(eigenPodBeacon) == address(0)) eigenPodBeacon = new UpgradeableBeacon(address(emptyContract));
        if (address(strategyBeacon) == address(0)) strategyBeacon = new UpgradeableBeacon(address(emptyContract));
        // multichain
        if (address(keyRegistrar) == address(0)) {
            keyRegistrar = KeyRegistrar(address(new TransparentUpgradeableProxy(address(emptyContract), address(eigenLayerProxyAdmin), "")));
        }
    }

    /// Deploy an implementation contract for each contract in the system
    function _deployImplementations() public {
        // Deploy AllocationManagerView as a standalone implementation (not a proxy)
        allocationManagerView =
            new AllocationManagerView(delegationManager, eigenStrategy, DEALLOCATION_DELAY, ALLOCATION_CONFIGURATION_DELAY);

        allocationManagerImplementation = IAllocationManager(
            address(
                new AllocationManager(
                    allocationManagerView,
                    delegationManager,
                    eigenStrategy,
                    eigenLayerPauserReg,
                    permissionController,
                    DEALLOCATION_DELAY,
                    ALLOCATION_CONFIGURATION_DELAY
                )
            )
        );
        permissionControllerImplementation = new PermissionController();
        delegationManagerImplementation = new DelegationManager(
            strategyManager,
            eigenPodManager,
            allocationManager,
            eigenLayerPauserReg,
            permissionController,
            DELEGATION_MANAGER_MIN_WITHDRAWAL_DELAY_BLOCKS,
            version
        );
        strategyManagerImplementation = new StrategyManager(allocationManager, delegationManager, eigenLayerPauserReg, version);
        rewardsCoordinatorImplementation = new RewardsCoordinator(
            IRewardsCoordinatorTypes.RewardsCoordinatorConstructorParams({
                delegationManager: delegationManager,
                strategyManager: strategyManager,
                allocationManager: allocationManager,
                pauserRegistry: eigenLayerPauserReg,
                permissionController: permissionController,
                CALCULATION_INTERVAL_SECONDS: REWARDS_COORDINATOR_CALCULATION_INTERVAL_SECONDS,
                MAX_REWARDS_DURATION: REWARDS_COORDINATOR_MAX_REWARDS_DURATION,
                MAX_RETROACTIVE_LENGTH: REWARDS_COORDINATOR_MAX_RETROACTIVE_LENGTH,
                MAX_FUTURE_LENGTH: REWARDS_COORDINATOR_MAX_FUTURE_LENGTH,
                GENESIS_REWARDS_TIMESTAMP: REWARDS_COORDINATOR_GENESIS_REWARDS_TIMESTAMP
            })
        );
        avsDirectoryImplementation = new AVSDirectory(delegationManager, eigenLayerPauserReg, version);
        eigenPodManagerImplementation = new EigenPodManager(DEPOSIT_CONTRACT, eigenPodBeacon, delegationManager, eigenLayerPauserReg);
        strategyFactoryImplementation = new StrategyFactory(strategyManager, eigenLayerPauserReg);

        // Beacon implementations
        eigenPodImplementation = new EigenPod(DEPOSIT_CONTRACT, eigenPodManager);
        baseStrategyImplementation = new StrategyBase(strategyManager, eigenLayerPauserReg);

        // Pre-longtail StrategyBaseTVLLimits implementation
        // TODO - need to update ExistingDeploymentParser

        // multichain
        keyRegistrarImplementation = new KeyRegistrar(permissionController, allocationManager, "9.9.9");
    }

    function _upgradeProxies() public noTracing {
        // DelegationManager
        eigenLayerProxyAdmin.upgrade(
            ITransparentUpgradeableProxy(payable(address(delegationManager))), address(delegationManagerImplementation)
        );

        // StrategyManager
        eigenLayerProxyAdmin.upgrade(
            ITransparentUpgradeableProxy(payable(address(strategyManager))), address(strategyManagerImplementation)
        );

        // EigenPodManager
        eigenLayerProxyAdmin.upgrade(
            ITransparentUpgradeableProxy(payable(address(eigenPodManager))), address(eigenPodManagerImplementation)
        );

        // RewardsCoordinator
        eigenLayerProxyAdmin.upgrade(
            ITransparentUpgradeableProxy(payable(address(rewardsCoordinator))), address(rewardsCoordinatorImplementation)
        );

        // AVSDirectory
        eigenLayerProxyAdmin.upgrade(ITransparentUpgradeableProxy(payable(address(avsDirectory))), address(avsDirectoryImplementation));

        // AllocationManager
        eigenLayerProxyAdmin.upgrade(
            ITransparentUpgradeableProxy(payable(address(allocationManager))), address(allocationManagerImplementation)
        );

        // PermissionController
        eigenLayerProxyAdmin.upgrade(
            ITransparentUpgradeableProxy(payable(address(permissionController))), address(permissionControllerImplementation)
        );

        // StrategyFactory
        eigenLayerProxyAdmin.upgrade(
            ITransparentUpgradeableProxy(payable(address(strategyFactory))), address(strategyFactoryImplementation)
        );

        // EigenPod beacon
        eigenPodBeacon.upgradeTo(address(eigenPodImplementation));

        // StrategyBase Beacon
        strategyBeacon.upgradeTo(address(baseStrategyImplementation));

        // Upgrade All deployed strategy contracts to new base strategy
        for (uint i = 0; i < numStrategiesDeployed; i++) {
            // Upgrade existing strategy
            eigenLayerProxyAdmin.upgrade(
                ITransparentUpgradeableProxy(payable(address(deployedStrategyArray[i]))), address(baseStrategyImplementation)
            );
        }

        // Key Registrar
        eigenLayerProxyAdmin.upgrade(ITransparentUpgradeableProxy(payable(address(keyRegistrar))), address(keyRegistrarImplementation));

        // PermissionController
        eigenLayerProxyAdmin.upgrade(
            ITransparentUpgradeableProxy(payable(address(permissionController))), address(permissionControllerImplementation)
        );
    }

    function _initializeProxies() public noTracing {
        delegationManager.initialize({initialPausedStatus: 0});

        strategyManager.initialize({
            initialOwner: executorMultisig,
            initialStrategyWhitelister: address(strategyFactory),
            initialPausedStatus: 0
        });

        eigenPodManager.initialize({initialOwner: executorMultisig, _initPausedStatus: 0});

        avsDirectory.initialize({initialOwner: executorMultisig, initialPausedStatus: 0});

        allocationManager.initialize({initialPausedStatus: 0});

        strategyFactory.initialize({_initialOwner: executorMultisig, _initialPausedStatus: 0, _strategyBeacon: strategyBeacon});
    }

    /// @dev Deploy a strategy and its underlying token, push to global lists of tokens/strategies, and whitelist
    /// strategy in strategyManager
    function _newStrategyAndToken(string memory tokenName, string memory tokenSymbol, uint initialSupply, address owner, bool useFactory)
        internal
        noTracing
    {
        IERC20 underlyingToken = new ERC20PresetFixedSupply(tokenName, tokenSymbol, initialSupply, owner);

        StrategyBase strategy;

        if (useFactory) {
            strategy = StrategyBase(address(strategyFactory.deployNewStrategy(underlyingToken)));
        } else {
            strategy = StrategyBase(
                address(
                    new TransparentUpgradeableProxy(
                        address(baseStrategyImplementation),
                        address(eigenLayerProxyAdmin),
                        abi.encodeWithSelector(StrategyBase.initialize.selector, underlyingToken)
                    )
                )
            );
        }

        // Whitelist strategy
        IStrategy[] memory strategies = new IStrategy[](1);
        strategies[0] = strategy;

        cheats.prank(strategyManager.strategyWhitelister());
        strategyManager.addStrategiesToDepositWhitelist(strategies);

        // Add to lstStrats and allStrats
        lstStrats.push(strategy);
        allStrats.push(strategy);
        allTokens.push(underlyingToken);
    }

    function _configRand(uint24 _randomSeed, uint _assetTypes, uint _userTypes) private noTracing {
        // Using uint24 for the seed type so that if a test fails, it's easier
        // to manually use the seed to replay the same test.
        random = _hash(_randomSeed);

        // Convert flag bitmaps to bytes of set bits for easy use with _randUint
        _configAssetTypes(_assetTypes);
        _configUserTypes(_userTypes);
    }

    function _configAssetTypes(uint _assetTypes) internal {
        assetTypes = _bitmapToBytes(_assetTypes);
        assertTrue(assetTypes.length != 0, "_configRand: no asset types selected");
    }

    function _configAssetAmounts(uint _maxUniqueAssetsHeld) internal {
        if (_maxUniqueAssetsHeld > allStrats.length) _maxUniqueAssetsHeld = allStrats.length;

        maxUniqueAssetsHeld = _maxUniqueAssetsHeld;
        require(maxUniqueAssetsHeld != 0, "_configAssetAmounts: invalid 0");
    }

    function _configUserTypes(uint _userTypes) internal {
        userTypes = _bitmapToBytes(_userTypes);
        assertTrue(userTypes.length != 0, "_configRand: no user types selected");
    }

    /// @dev Create a new User with a random config using the range defined in `_configRand`
    ///
    /// Assets are pulled from `strategies` based on a random staker/operator `assetType`
    function _randUser(string memory name) internal noTracing returns (User, IStrategy[] memory, uint[] memory) {
        // Deploy new User contract
        uint userType = _randUserType();
        User user = _genRandUser(name, userType);

        // For the specific asset selection we made, get a random assortment of strategies
        // and deal the user some corresponding underlying token balances
        uint assetType = _randAssetType();
        IStrategy[] memory strategies = _selectRandAssets(assetType);
        uint[] memory tokenBalances = _dealRandAmounts(user, strategies);

        print.user(name, assetType, userType, strategies, tokenBalances);
        return (user, strategies, tokenBalances);
    }

    function _randUser(string memory name, IStrategy[] memory strategies) internal noTracing returns (User, uint[] memory) {
        // Deploy new User contract
        uint userType = _randUserType();
        User user = _genRandUser(name, userType);

        // Deal the user some corresponding underlying token balances
        uint[] memory tokenBalances = _dealRandAmounts(user, strategies);

        print.user(name, HOLDS_ALL, userType, strategies, tokenBalances);
        return (user, tokenBalances);
    }

    /// @dev Create a new user without native ETH. See _randUser above for standard usage
    function _randUser_NoETH(string memory name) internal noTracing returns (User, IStrategy[] memory, uint[] memory) {
        // Deploy new User contract
        uint userType = _randUserType();
        User user = _genRandUser(name, userType);

        // Pick the user's asset distribution, removing "native ETH" as an option
        // I'm sorry if this eventually leads to a bug that's really hard to track down
        uint assetType = _randAssetType();
        if (assetType == HOLDS_ETH) assetType = NO_ASSETS;
        else if (assetType == HOLDS_ALL || assetType == HOLDS_MAX) assetType = HOLDS_LST;

        // For the specific asset selection we made, get a random assortment of strategies
        // and deal the user some corresponding underlying token balances
        IStrategy[] memory strategies = _selectRandAssets(assetType);
        uint[] memory tokenBalances = _dealRandAmounts(user, strategies);

        print.user(name, assetType, userType, strategies, tokenBalances);
        return (user, strategies, tokenBalances);
    }

    /// @dev Creates a new user without any assets
    function _randUser_NoAssets(string memory name) internal noTracing returns (User) {
        // Deploy new User contract
        uint userType = _randUserType();
        User user = _genRandUser(name, userType);

        print.user(name, NO_ASSETS, userType, new IStrategy[](0), new uint[](0));
        return user;
    }

    function _genRandUser(string memory name, uint userType) internal returns (User user) {
        // Create User contract based on userType:
        if (forkType == LOCAL || (forkType == MAINNET && isUpgraded)) {
            user = new User(name);

            if (userType == DEFAULT) {
                user = new User(name);
            } else if (userType == ALT_METHODS) {
                // User will use nonstandard methods like `depositIntoStrategyWithSignature`
                user = User(new User_AltMethods(name));
            } else {
                revert("_randUser: unimplemented userType");
            }
            // Leaving this if statement for future upgraded users
        } else if (forkType == MAINNET && !isUpgraded) {
            if (userType == DEFAULT) {
                user = new User(name);
            } else if (userType == ALT_METHODS) {
                // User will use nonstandard methods like `depositIntoStrategyWithSignature`
                user = User(new User_AltMethods(name));
            } else {
                revert("_randUser: unimplemented userType");
            }
        } else {
            revert("_randUser: unimplemented forkType");
        }
    }

    function _genRandAVS(string memory name) internal returns (AVS avs) {
        if (forkType == LOCAL) avs = new AVS(name);
        else if (forkType == MAINNET) avs = new AVS(name);
        else revert("_genRandAVS: unimplemented forkType");
    }

    /// Given an assetType, select strategies the user will be dealt assets in
    function _selectRandAssets(uint assetType) internal noTracing returns (IStrategy[] memory) {
        if (assetType == NO_ASSETS) return new IStrategy[](0);

        /// Select only ETH
        if (assetType == HOLDS_ETH) return beaconChainETHStrategy.toArray();

        /// Select multiple LSTs, and maybe add ETH:

        // Select number of assets:
        // HOLDS_LST can hold at most all LSTs. HOLDS_ALL and HOLDS_MAX also hold ETH.
        // Clamp number of assets to maxUniqueAssetsHeld (guaranteed to be at least 1)
        uint assetPoolSize = assetType == HOLDS_LST ? lstStrats.length : allStrats.length;
        uint maxAssets = assetPoolSize > maxUniqueAssetsHeld ? maxUniqueAssetsHeld : assetPoolSize;

        uint numAssets = assetType == HOLDS_MAX ? maxAssets : _randUint(1, maxAssets);

        IStrategy[] memory strategies = new IStrategy[](numAssets);
        for (uint i = 0; i < strategies.length; i++) {
            if (assetType == HOLDS_LST) {
                strategies[i] = lstStrats[i];
            } else {
                // allStrats[0] is the beaconChainETHStrategy
                strategies[i] = allStrats[i];
            }
        }

        return strategies;
    }

    /// Given an input list of strategies, deal random underlying token amounts to a user
    function _dealRandAmounts(User user, IStrategy[] memory strategies) internal noTracing returns (uint[] memory) {
        uint[] memory tokenBalances = new uint[](strategies.length);

        for (uint i = 0; i < tokenBalances.length; i++) {
            IStrategy strategy = strategies[i];
            uint balance;

            if (strategy == BEACONCHAIN_ETH_STRAT) {
                // Award the user with a random amount of ETH
                // This guarantees a multiple of 32 ETH (at least 1, up to/incl 2080)
                uint amount = 32 ether * _randUint({min: 1, max: 65});
                balance = 32 ether * _randUint({min: 1, max: 5});
                cheats.deal(address(user), balance);
            } else {
                IERC20 underlyingToken = strategy.underlyingToken();
                balance = _randUint({min: MIN_BALANCE, max: MAX_BALANCE});

                StdCheats.deal(address(underlyingToken), address(user), balance);
            }

            tokenBalances[i] = balance;
        }

        return tokenBalances;
    }

    /// Given an array of strategies and an array of amounts, deal the amounts to the user
    function _dealAmounts(User user, IStrategy[] memory strategies, uint[] memory amounts) internal noTracing {
        for (uint i = 0; i < amounts.length; i++) {
            IStrategy strategy = strategies[i];

            if (strategy == BEACONCHAIN_ETH_STRAT) {
                cheats.deal(address(user), amounts[i]);
            } else {
                IERC20 underlyingToken = strategy.underlyingToken();
                StdCheats.deal(address(underlyingToken), address(user), amounts[i]);
            }
        }
    }

    /// @dev Uses `random` to return a random uint, with a range given by `min` and `max` (inclusive)
    /// @return `min` <= result <= `max`
    function _randUint(uint min, uint max) internal returns (uint) {
        uint range = max - min + 1;

        // calculate the number of bits needed for the range
        uint bitsNeeded = 0;
        uint tempRange = range;
        while (tempRange > 0) {
            bitsNeeded++;
            tempRange >>= 1;
        }

        // create a mask for the required number of bits
        // and extract the value from the hash
        uint mask = (1 << bitsNeeded) - 1;
        uint value = uint(random) & mask;

        // in case value is out of range, wrap around or retry
        while (value >= range) value = (value - range) & mask;

        // Hash `random` with itself so the next value we generate is different
        random = _hash(uint(random));
        return min + value;
    }

    function _randBool() internal returns (bool) {
        return _randUint({min: 0, max: 1}) == 0;
    }

    function _randAssetType() internal returns (uint) {
        uint idx = _randUint({min: 0, max: assetTypes.length - 1});
        uint assetType = uint(uint8(assetTypes[idx]));

        return assetType;
    }

    function _randUserType() internal returns (uint) {
        uint idx = _randUint({min: 0, max: userTypes.length - 1});
        uint userType = uint(uint8(userTypes[idx]));

        return userType;
    }

    function _randomStrategies() internal returns (IStrategy[][] memory strategies) {
        uint numOpSets = _randUint({min: 1, max: 5});

        strategies = new IStrategy[][](numOpSets);

        for (uint i; i < numOpSets; ++i) {
            IStrategy[] memory randomStrategies = allStrats.shuffle();
            uint numStrategies = _randUint({min: 1, max: maxUniqueAssetsHeld});

            // Modify the length of the array in memory (thus ignoring remaining elements).
            assembly {
                mstore(randomStrategies, numStrategies)
            }

            strategies[i] = randomStrategies;
        }
    }

    /// @dev Converts a bitmap into an array of bytes
    /// @dev Each byte in the input is processed as indicating a single bit to flip in the bitmap
    function _bitmapToBytes(uint bitmap) internal pure returns (bytes memory bytesArray) {
        for (uint i = 0; i < 256; ++i) {
            // Mask for i-th bit
            uint mask = uint(1 << i);

            // If the i-th bit is flipped, add a byte to the return array
            if (bitmap & mask != 0) bytesArray = bytes.concat(bytesArray, bytes1(uint8(1 << i)));
        }
        return bytesArray;
    }

    function _hash(string memory x) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(x));
    }

    function _hash(uint x) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(x));
    }
}
