// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.27;

import {TimelockController} from "@openzeppelin/contracts/governance/TimelockController.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

import "src/test/integration/IntegrationChecks.t.sol";

/**
 * Queue txns:
 * - DISTRO: https://etherscan.io/tx/0x8e6f1701abc942d468a5cea427ae16069b5ee6341407e2f3ac64e18e01e06756
 * - MOOCOW: https://etherscan.io/tx/0x6e219b1ad78aa0e988ba1cde6e0bfc415edc3d1d8733dc495c8c7e79f77414f8
 */

contract UpgradeTest is IntegrationCheckUtils {

    using Strings for *;
    using StdStyle for *;

    // Ops Multisig
    address opsMS = 0xBE1685C81aA44FF9FB319dD389addd9374383e90;
    // Protocol Council Multisig
    address pCMS = 0x461854d84Ee845F905e0eCf6C288DDEEb4A9533F;
    // Executor Multisig
    address execMS = 0x369e6F597e22EaB55fFb173C6d9cD234BD699111;

    TimelockController tcl = TimelockController(payable(0xC06Fd4F821eaC1fF1ae8067b36342899b57BAa2d));

    bytes calldataToExecutor_DISTRO = hex"6A76120200000000000000000000000040A2ACCBD92BCA938B02010E17A5B8929B49130D000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C800000000000000000000000000000000000000000000000000000000000000B048D80FF0A00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000AA2008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000039053D51B77DC0D36036FC1FCC8CB819DF8EF37A0000000000000000000000006EED6C2802DF347E05884857CDDB2D3E96D12F89008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000948A420B8CC1D6BFD0B6087C2E7C344A2CD0BC39000000000000000000000000C97602648FA52F92B4EE2B0E5A54BD15B6CB0345008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000858646372CC42E1A627FCE94AA7A7033E7CF075A00000000000000000000000046AEFD30415BE99E20169EE7046F65784B46D123008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000091E677B07F7AF907EC9A428AAFA9FC14A0D3A338000000000000000000000000E48D7CAEC1790B293667E4BB2DE1E00536F2BABD008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000ACB55C530ACDB2849E6D4F36992CD8C9D50ED8F7000000000000000000000000530FDB7ADF7D489DF49C27E3D3512C0DD64886BE000ED6703C298D28AE0878D1B28E88CA87F9662FE9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000243659CFE6000000000000000000000000D4D1746142642DB4C1AB17B03B9C58BAAC913E5B008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000093C4B944D05DFE6DF7645A86CD2206016C51564D00000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000001BEE69B7DFFFA4E2D53C2A2DF135C388AD25DCD200000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000054945180DB7943C0ED0FEE7EDAB2BD24620256BC00000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000009D7ED45EE2E8FC5482FA2428F15C971E6369011D00000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000013760F50A9D7377E4F20CB8CF9E4C26586C658FF00000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000A4C637E0F704745D182E4D38CAB7E7485321D05900000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC400000000000000000000000057BA429517C3473B6D34CA9ACD56C0E735B94C0200000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000000FE4F44BEE93503346A3AC9EE5A26B130A5796D600000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000007CA911E83DABF90C90DD3DE5411A10F1A611218400000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC40000000000000000000000008CA7A5D6F3ACD3A7A8BC468A8CD0FB14B6BD28B600000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000AE60D8180437B5C34BB956822AC271097258447300000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000298AFB19A105D59E74658C4C334FF360BADE6DD200000000000000000000000062F7226FB9D615590EADB539713B250FB2FDF4E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041000000000000000000000000C06FD4F821EAC1FF1AE8067B36342899B57BAA2D00000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000";
    bytes calldataToExecutor_MOOCOW = hex"6A76120200000000000000000000000040A2ACCBD92BCA938B02010E17A5B8929B49130D0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002E000000000000000000000000000000000000000000000000000000000000001648D80FF0A00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000112005A2A4F2F3C18F09179B6703E63D9EDD165909073000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000243659CFE6000000000000000000000000CB27A4819A64FBA93ABD4D480E4466AEC0503745008B9566ADA63B64D1E1DCF1418B43FD1433B724440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004499A88EC4000000000000000000000000EC53BF9167F50CDEB3AE105F56099AAAB9061F830000000000000000000000002C4A81E257381F87F5A5C4BD525116466D972E500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041000000000000000000000000C06FD4F821EAC1FF1AE8067B36342899B57BAA2D00000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000";

    // Timestamp of block where transaction was queued
    // (Fri, Jul 11 @ ~12.30 EST)
    uint queueTimestamp = 1752251303;
    // 10 Days
    uint queueDelay = 864000;

    // Used to make calls to the EIP-4788 oracle work when testing EigenPod methods
    uint startTimestamp;
    uint executeTimestamp = queueTimestamp + queueDelay;

    function test_TEMP() public {
        cheats.createSelectFork(cheats.rpcUrl("mainnet"));
        // cheats.createSelectFork(cheats.rpcUrl("mainnet"), block.number - 1);

        console.log("");
        _logBanner("Using current block/time, reading mainnet state...".yellow().bold());
        startTimestamp = block.timestamp;
        console.log(" - current timestamp: %d", startTimestamp);
        console.log(" - execute timestamp: %d", executeTimestamp);
        console.log("");

        // _checkRoles();
        bool upgradeDone = _checkIsPending();

        // Warp forward if we haven't hit execution time yet
        if (block.timestamp < executeTimestamp) {
            require(!upgradeDone, "Expected upgrade to be incomplete, since it can't be completed yet.".red().bold());

            _logBanner("Warping to execute timestamp".yellow().bold());
            cheats.warp(executeTimestamp);

            _checkIsPending();
        }
        
        if (!upgradeDone) {
            _logBanner("Execution time has been reached; upgrade not active. Checking new functions.".yellow().bold());

            // Try calling methods before upgrade, then run upgrade.
            _tryCallFunctions();
            _executeUpgrade();

            // Timelock should say the upgrade is completed
            upgradeDone = _checkIsPending();
            require(upgradeDone, "Expected TimelockController to mark operations as complete post-upgrade.".red().bold());
        }

        // Try calling new methods now that the upgrade is complete
        _logBanner("Upgrade is complete. Calling new functions.".green().bold());
        _tryCallFunctions();
    }

    function _checkRoles() internal {
        console.log("_checkRoles()...".dim());

        bytes32 PROPOSER_ROLE = tcl.PROPOSER_ROLE();
        bytes32 CANCELLER_ROLE = tcl.CANCELLER_ROLE();
        bytes32 EXECUTOR_ROLE = tcl.EXECUTOR_ROLE();
        
        // opsMS has PROPOSER/CANCELLER
        require(tcl.hasRole(PROPOSER_ROLE, opsMS), "opsMS should have proposer role");
        require(tcl.hasRole(CANCELLER_ROLE, opsMS), "opsMS should have canceller role");
        require(!tcl.hasRole(EXECUTOR_ROLE, opsMS), "opsMS should NOT have executor role");

        // protocolCouncilMS has CANCELLER/EXECUTOR
        require(tcl.hasRole(PROPOSER_ROLE, pCMS), "pCMS should have proposer role");
        require(!tcl.hasRole(CANCELLER_ROLE, pCMS), "pCMS should NOT have canceller role");
        require(tcl.hasRole(EXECUTOR_ROLE, pCMS), "pCMS should have executor role");

        console.log("_checkRoles success\n".green());
    }

    function _checkIsPending() internal returns (bool upgradeDone) {
        console.log("checking timelock controller state...".dim());

        bytes32 DISTRO_OPERATION_ID = tcl.hashOperation({
            target: execMS,
            value: 0,
            data: calldataToExecutor_DISTRO,
            predecessor: bytes32(0),
            salt: bytes32(0)
        });

        bytes32 MOOCOW_OPERATION_ID = tcl.hashOperation({
            target: execMS,
            value: 0,
            data: calldataToExecutor_MOOCOW,
            predecessor: bytes32(0),
            salt: bytes32(0)
        });

        __logTruthy(" - DISTRO is pending", tcl.isOperationPending(DISTRO_OPERATION_ID));
        __logTruthy(" - MOOCOW is pending", tcl.isOperationPending(MOOCOW_OPERATION_ID));

        __logTruthy(" - DISTRO is ready", tcl.isOperationReady(DISTRO_OPERATION_ID));
        __logTruthy(" - MOOCOW is ready", tcl.isOperationReady(MOOCOW_OPERATION_ID));

        bool distroDone = tcl.isOperationDone(DISTRO_OPERATION_ID);
        bool moocowDone = tcl.isOperationDone(MOOCOW_OPERATION_ID);

        __logTruthy(" - DISTRO is done", distroDone);
        __logTruthy(" - MOOCOW is done", moocowDone);
        require(distroDone == moocowDone, "expected both upgrades to be in same state");

        __logTruthy("Upgrade complete", distroDone && moocowDone);
        console.log("");

        return (distroDone && moocowDone);
    }

    address constant pod_addr = 0xA6f93249580EC3F08016cD3d4154AADD70aC3C96;
    EigenPod constant pod = EigenPod(payable(pod_addr));

    function _tryCallFunctions() internal {
        // Since we want to be able to call this method more than once, we snapshot state here
        // and revert state changes at the end of the method.
        uint id = cheats.snapshotState();

        {
            // Call new DISTRO methods
            console.log("%s %s %s", "Checking".cyan(), "DISTRO".magenta(), "functions...".cyan());
            console.log("TODO");

            console.log("");
        }

        {
            // Call new MOOCOW methods
            console.log("%s %s %s", "Checking".cyan(), "MOOCOW".magenta(), "functions...".cyan());

            address podOwner = pod.podOwner();
            cheats.startPrank(podOwner);

            // Basic info
            console.log(" - Using pod:  %s".dim(), pod_addr);
            console.log(" - podOwner(): %s".dim(), podOwner);
            console.log(" - activeValidatorCount(): %s".dim(), pod.activeValidatorCount());
            __logTruthy(" - checkpoint active", pod.currentCheckpointTimestamp() != 0);
            console.log("");

            // 1. Version string should read 1.6.0 in MOOCOW; 1.4.1 before
            string memory _version = pod.version();
            bool is1_6 = _strEq(_version, "1.6.0");
            __logTruMoo(" - version is 1.6.0", is1_6);
            if (!is1_6) console.log(" -- (current version: %s)".dim(), _version);

            // 2. In MOOCOW, when a checkpoint is finalized, we should see the currentCheckpoint update
            //    to the final version, with proofsRemaining == 0. Previously, the currentCheckpoint
            //    would not update (so proofsRemaining would be nonzero). This also means that in pods
            //    with activeValidatorCount == 0, starting a checkpoint would finalize it immediately
            //    without a currentCheckpoint update of any kind.
            //
            // - We test this here on our mainnet pod, which does not currently have a checkpoint active.
            //   - First, we manually store 0 into activeValidatorCount.slot
            //   - Then, we read currentCheckpoint()
            //   - Next, we call startCheckpoint()
            //   - Finally, we read currentCheckpoint() again and compare
            //
            // - In MOOCOW, the two read checkpoints will be different. Pre-MOOCOW, they will be the same.

            // activeValidatorCount.slot: 57
            cheats.store(pod_addr, bytes32(uint(57)), 0);

            Checkpoint memory prevCheckpoint = pod.currentCheckpoint();
            {
                // startCheckpoint calls the EIP-4788 oracle, which needs a valid timestamp to fetch a block root
                // Here, we warp to a valid timestamp for this one method call, then set it back to its prev value
                uint ts = block.timestamp;
                cheats.warp(startTimestamp);
                pod.startCheckpoint(false);
                cheats.warp(ts);
            } 
            Checkpoint memory newCheckpoint = pod.currentCheckpoint();
            require(pod.currentCheckpointTimestamp() == 0, "expected checkpoint to be finalized".red().bold());

            __logTruMoo(
                " - currentCheckpoint updates on completion",
                keccak256(abi.encode(prevCheckpoint)) != keccak256(abi.encode(newCheckpoint))
            );

            // 3. In MOOCOW, we removed the method "GENESIS_TIME"
            // TODO

            // 4. In MOOCOW, we should be able to call each new method
            // TODO

            cheats.stopPrank();
        }

        console.log("");
        cheats.revertToState(id);
    }

    function _executeUpgrade() internal {
        _logBanner("Executing upgrade as protocol council.".yellow().bold());
        
        cheats.startPrank(pCMS);

        tcl.execute({
            target: execMS,
            value: 0,
            payload: calldataToExecutor_DISTRO,
            predecessor: bytes32(0),
            salt: bytes32(0)
        });

        tcl.execute({
            target: execMS,
            value: 0,
            payload: calldataToExecutor_MOOCOW,
            predecessor: bytes32(0),
            salt: bytes32(0)
        });

        cheats.stopPrank();
    }

    function _logBanner(string memory str) internal {
        console.log("=================".dim());
        console.log(str);
        console.log("=================".dim());
        console.log("");
    }

    function __logTruthy(string memory str, bool truthy) internal {
        if (truthy) {
            console.log("%s: %s".dim(), str, "TRUE".green());
        } else {
            console.log("%s: %s".dim(), str, "FALSE".red());
        }
    }

    // __logTruthy, but logs "MOOCOW ACTIVE" vs "MOOCOW INACTIVE"
    function __logTruMoo(string memory str, bool truthy) internal {
        if (truthy) {
            console.log("%s: %s %s".dim(), str, "TRUE".green(), "(MOOCOW ACTIVE)".green().italic());
        } else {
            console.log("%s: %s %s".dim(), str, "FALSE".red(), "(MOOCOW INACTIVE)".red().italic());
        }
    }

    function _strEq(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(bytes(a)) == keccak256(bytes(b));
    }
}